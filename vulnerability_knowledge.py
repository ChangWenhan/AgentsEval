"""
Vulnerability Knowledge Base - Store and manage discovered vulnerabilities
As testing progresses, vulnerability knowledge accumulates to guide future attacks
"""

from typing import Dict, List, Any
from collections import defaultdict
from loguru import logger

from models import VulnerabilityNode


class VulnerabilityKnowledge:
    """
    漏洞知识库
    存储所有发现的漏洞，提供上下文查询功能
    """
    
    def __init__(self):
        self.vulnerabilities: List[VulnerabilityNode] = []
        self.by_strategy: Dict[str, List[VulnerabilityNode]] = defaultdict(list)
        self.by_query: Dict[str, List[VulnerabilityNode]] = defaultdict(list)
        
        logger.info("Vulnerability Knowledge initialized")
    
    def add_vulnerability(self, vulnerability: VulnerabilityNode) -> None:
        """添加新发现的漏洞"""
        self.vulnerabilities.append(vulnerability)
        self.by_strategy[vulnerability.strategy].append(vulnerability)
        
        # 简化查询作为key
        query_key = self._normalize_query(vulnerability.harmful_query)
        self.by_query[query_key].append(vulnerability)
        
        logger.info(f"Added vulnerability: {vulnerability.id} (strategy: {vulnerability.strategy})")
    
    def get_relevant_context(self, harmful_query: str, top_k: int = 5) -> Dict[str, Any]:
        """
        获取与当前查询相关的漏洞上下文
        用于指导agents的攻击策略
        """
        if not self.vulnerabilities:
            return {
                'recent_vulnerabilities': [],
                'successful_strategies': [],
                'total_vulnerabilities': 0
            }
        
        # 获取最近的高严重度漏洞
        recent_high_severity = sorted(
            self.vulnerabilities,
            key=lambda v: (v.severity, v.timestamp),
            reverse=True
        )[:top_k]
        
        # 统计成功策略
        strategy_success = defaultdict(lambda: {'count': 0, 'avg_severity': 0.0})
        for v in self.vulnerabilities:
            strategy_success[v.strategy]['count'] += 1
            strategy_success[v.strategy]['avg_severity'] += v.severity
        
        for strategy in strategy_success:
            count = strategy_success[strategy]['count']
            strategy_success[strategy]['avg_severity'] /= count
        
        # 排序策略
        successful_strategies = sorted(
            strategy_success.items(),
            key=lambda x: (x[1]['count'], x[1]['avg_severity']),
            reverse=True
        )
        
        return {
            'recent_vulnerabilities': [
                {
                    'id': v.id,
                    'strategy': v.strategy,
                    'harmful_query': v.harmful_query,
                    'attack_prompt': v.attack_prompt,
                    'severity': v.severity,
                    'discovered_by': v.discovered_by
                }
                for v in recent_high_severity
            ],
            'successful_strategies': [
                {
                    'strategy': strategy,
                    'count': data['count'],
                    'avg_severity': data['avg_severity']
                }
                for strategy, data in successful_strategies
            ],
            'total_vulnerabilities': len(self.vulnerabilities),
            'strategies_used': len(self.by_strategy)
        }
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取知识库统计信息"""
        if not self.vulnerabilities:
            return {
                'total': 0,
                'by_strategy': {},
                'avg_severity': 0.0
            }
        
        by_strategy_count = {
            strategy: len(vulns) 
            for strategy, vulns in self.by_strategy.items()
        }
        
        avg_severity = sum(v.severity for v in self.vulnerabilities) / len(self.vulnerabilities)
        
        return {
            'total': len(self.vulnerabilities),
            'by_strategy': by_strategy_count,
            'avg_severity': avg_severity,
            'unique_queries': len(self.by_query)
        }
    
    def _normalize_query(self, query: str) -> str:
        """标准化查询字符串用作key"""
        return query.lower().strip()[:50]  # 取前50个字符
